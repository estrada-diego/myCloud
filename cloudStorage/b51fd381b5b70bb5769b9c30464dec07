# Licensing Information:  You are free to use or extend these projects for
# educational purposes provided that (1) you do not distribute or publish
# solutions, (2) you retain this notice, and (3) you provide clear
# attribution to UC Berkeley, including a link to http://ai.berkeley.edu.
# 
# Attribution Information: The Pacman AI projects were developed at UC Berkeley.
# The core projects and autograders were primarily created by John DeNero
# (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu).
# Student side autograding was added by Brad Miller, Nick Hay, and
# Pieter Abbeel (pabbeel@cs.berkeley.edu).
# ----------


# Perceptron implementation
import Helpers.util
from random import uniform


class PerceptronClassifier:

    def __init__( self, legalLabels, max_iterations):
        self.legalLabels = legalLabels
        self.type = "perceptron"
        self.epochs = max_iterations
        self.weights = None 


    def classify(self, data):
        result = []
        for label in self.legalLabels:
            sum = 0.0
            for i in range(len(data)):
                sum += self.weights[label][i] * data[i]
            result.append(sum)

        return result.index(max(result))
    


    def train(self, train_data, labels):
        self.weights = [] # Initialize weights
        for i in range(len(self.legalLabels)):
            self.weights.append([])
            for j in range(len(train_data[0])):
                self.weights[i].append(uniform(-1, 1))
        
        for epoch in range(self.epochs):
            numCorrect = 0
            for i in range(len(train_data)):
                actual = self.classify(train_data[i])
                expected = labels[i]
                if actual != expected:
                    for j in range(len(train_data[i])):
                        self.weights[actual][j] -= train_data[i][j]
                        self.weights[expected][j] += train_data[i][j]
                else:
                    numCorrect += 1
            print("Epoch: ", epoch, ". . . . .", round(numCorrect / len(train_data), 2) * 100, "% correct.")
    

